const VERSION = '3.346';
// Set a name for the current cache
var cacheName = `v${VERSION}`;

// Default files to always cache
var cacheFiles = [
	`/js/main.${VERSION}.min.js`,
	`/css/styles.${VERSION}.min.css`,
	'https://fonts.googleapis.com/css?family=Open+Sans:100,100i,300,300i,700,700i|Playfair+Display:400,400i|Nixie+One|Source+Code+Pro',
	'/offline/'
]

self.addEventListener('install', e => {
	console.log( `[ServiceWorker] Installed ${cacheName}` );

	e.waitUntil(

		caches.open(cacheName).then( cache => {
			return cache.addAll(cacheFiles);
		}).then(function() {
			return self.skipWaiting();
		})

	);

});


self.addEventListener('activate', e => {

	console.log( `[ServiceWorker] Activated ${cacheName}` );

	e.waitUntil(

		caches.keys().then( cacheNames => {

			Promise.all( cacheNames.map( thisCacheName => {
				if (thisCacheName !== cacheName) {
					console.log( `[ServiceWorker] Delete ${thisCacheName}`)
					return caches.delete(thisCacheName);
				}
			})).then( () => {
				return self.clients.claim();
			})
		})

	);

});


self.addEventListener('fetch', event => {

	if (event.request.method !== 'GET') {
		console.log('WORKER: fetch event ignored.', event.request.method, event.request.url);
		return;
	}

	if ( event.request.headers.get('range') !== null ) {
		return;
	}

	event.respondWith(
		caches.match(event.request).then( resp => {
			return resp || fetch(event.request).then( response => {

				if( event.request.url.indexOf( 'fonts.gstatic.com' ) !== -1 ) {

					var r = response.clone();
					caches.open(cacheName).then(function(cache) {
						cache.put(event.request, r);
					});
				}

				return response;
			}).catch( e => {
				return caches.match( '/offline/' );
			});
		})
	);

});


